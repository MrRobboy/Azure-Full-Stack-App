<!DOCTYPE html>
<html lang="fr">
	<head>
		<meta charset="UTF-8" />
		<meta
			name="viewport"
			content="width=device-width, initial-scale=1.0" />
		<title>Test Avancé de Proxy Azure</title>
		<style>
			body {
				font-family: Arial, sans-serif;
				line-height: 1.6;
				margin: 0;
				padding: 20px;
				color: #333;
			}
			.container {
				max-width: 1200px;
				margin: 0 auto;
			}
			h1 {
				color: #0078d4;
				border-bottom: 2px solid #0078d4;
				padding-bottom: 10px;
			}
			h2 {
				color: #0078d4;
				margin-top: 30px;
			}
			.card {
				background: #f9f9f9;
				border: 1px solid #ddd;
				border-radius: 5px;
				padding: 15px;
				margin-bottom: 20px;
			}
			button {
				background: #0078d4;
				color: white;
				border: none;
				padding: 10px 15px;
				border-radius: 4px;
				cursor: pointer;
				margin: 5px;
			}
			button:hover {
				background: #005a9e;
			}
			.success {
				color: green;
				font-weight: bold;
			}
			.error {
				color: red;
				font-weight: bold;
			}
			.warning {
				color: orange;
				font-weight: bold;
			}
			.test-grid {
				display: grid;
				grid-template-columns: repeat(
					auto-fill,
					minmax(300px, 1fr)
				);
				gap: 15px;
			}
			.test-item {
				border: 1px solid #ddd;
				padding: 10px;
				border-radius: 4px;
			}
			pre {
				background: #f5f5f5;
				padding: 10px;
				border-radius: 4px;
				overflow: auto;
				max-height: 150px;
			}
			table {
				width: 100%;
				border-collapse: collapse;
				margin-bottom: 20px;
			}
			th,
			td {
				border: 1px solid #ddd;
				padding: 8px;
				text-align: left;
			}
			th {
				background-color: #f2f2f2;
			}
			textarea {
				width: 100%;
				height: 100px;
				font-family: monospace;
			}
			.methods {
				display: flex;
				gap: 10px;
				margin-bottom: 10px;
			}
		</style>
	</head>
	<body>
		<div class="container">
			<h1>Test Avancé de Proxy Azure</h1>

			<div class="card">
				<h2>Informations sur l'environnement</h2>
				<div id="env-info"></div>
			</div>

			<div class="card">
				<h2>Test de chemins de proxy</h2>
				<p>
					Cette section teste les différents
					chemins de proxy pour déterminer
					lesquels sont accessibles.
				</p>
				<div class="methods">
					<button onclick="testAllProxies()">
						Tester tous les chemins
					</button>
					<button onclick="testAllProxiesPost()">
						Tester POST sur tous les chemins
					</button>
				</div>
				<div id="proxy-results" class="test-grid"></div>
			</div>

			<div class="card">
				<h2>Test de connexion direct</h2>
				<p>
					Tester la connexion directe au backend
					(problèmes potentiels de CORS)
				</p>
				<button onclick="testDirectBackend()">
					Tester connexion directe
				</button>
				<div id="direct-result"></div>
			</div>

			<div class="card">
				<h2>Contournement avec FORM + IFRAME</h2>
				<p>
					Cette méthode utilise un iframe et un
					formulaire pour contourner les problèmes
					de CORS et 404
				</p>
				<div>
					<label for="test-endpoint"
						>Endpoint à tester:</label
					>
					<input
						type="text"
						id="test-endpoint"
						value="api/auth/status"
						style="width: 300px" />
				</div>
				<div>
					<label for="test-data"
						>Données JSON (pour
						POST):</label
					>
					<textarea id="test-data">
{
    "test": true,
    "timestamp": "2025-05-15"
}</textarea
					>
				</div>
				<button onclick="testIframePostMethod()">
					Tester Méthode IFRAME
				</button>
				<div id="iframe-result"></div>
			</div>

			<div class="card">
				<h2>Solutions recommandées</h2>
				<div id="recommendations"></div>
			</div>
		</div>

		<script>
			// Informations sur l'environnement
			const isAzure =
				window.location.hostname.includes(
					"azurewebsites.net"
				);
			const recommendations = [];
			let workingProxies = [];
			let workingPostProxies = [];

			// Chemins à tester
			const proxyPaths = [
				"simple-proxy.php",
				"api-bridge.php",
				"direct-login.php",
				"local-proxy.php",
				"local-proxy-fix.php",
				"/simple-proxy.php",
				"/api-bridge.php",
				"/direct-login.php",
				"/local-proxy.php",
				"/local-proxy-fix.php",
				"/api/simple-proxy.php",
				"/api/api-bridge.php",
				"/api/local-proxy.php",
				"/api/local-proxy-fix.php",
				"/proxy/simple-proxy.php",
				"/proxy/api-bridge.php",
				"/proxy/local-proxy.php",
				"/proxy/local-proxy-fix.php"
			];

			// Afficher les informations d'environnement
			function showEnvironmentInfo() {
				const envInfo =
					document.getElementById("env-info");

				const info = {
					Hostname: window.location.hostname,
					"URL complète": window.location.href,
					Chemin: window.location.pathname,
					Environnement: isAzure
						? "Azure"
						: "Local",
					"User Agent": navigator.userAgent,
					Date: new Date().toISOString()
				};

				let infoHtml = "<table>";
				for (const [key, value] of Object.entries(
					info
				)) {
					infoHtml += `<tr><th>${key}</th><td>${value}</td></tr>`;
				}
				infoHtml += "</table>";

				envInfo.innerHTML = infoHtml;
			}

			// Tester tous les chemins de proxy (GET)
			async function testAllProxies() {
				const resultsDiv =
					document.getElementById(
						"proxy-results"
					);
				resultsDiv.innerHTML =
					"<p>Test en cours...</p>";

				workingProxies = [];
				let resultsHtml = "";

				for (const path of proxyPaths) {
					try {
						const testResult =
							await testProxyPath(
								path
							);
						resultsHtml += `<div class="test-item">
                        <div class="${
				testResult.success ? "success" : "error"
			}">${path}</div>
                        <div>Status: ${testResult.status}</div>
                        <div>Méthode: GET</div>
                        ${
				testResult.success
					? "<div>✅ Fonctionnel</div>"
					: "<div>❌ Échoué</div>"
			}
                    </div>`;

						if (testResult.success) {
							workingProxies.push(
								path
							);
						}
					} catch (error) {
						resultsHtml += `<div class="test-item">
                        <div class="error">${path}</div>
                        <div>Erreur: ${error.message}</div>
                        <div>❌ Échoué</div>
                    </div>`;
					}
				}

				resultsDiv.innerHTML = resultsHtml;
				updateRecommendations();
			}

			// Tester tous les chemins de proxy (POST)
			async function testAllProxiesPost() {
				const resultsDiv =
					document.getElementById(
						"proxy-results"
					);
				resultsDiv.innerHTML =
					"<p>Test POST en cours...</p>";

				workingPostProxies = [];
				let resultsHtml = "";

				for (const path of proxyPaths) {
					try {
						const testResult =
							await testProxyPathPost(
								path
							);
						resultsHtml += `<div class="test-item">
                        <div class="${
				testResult.success ? "success" : "error"
			}">${path}</div>
                        <div>Status: ${testResult.status}</div>
                        <div>Méthode: POST</div>
                        ${
				testResult.success
					? "<div>✅ Fonctionnel</div>"
					: "<div>❌ Échoué</div>"
			}
                    </div>`;

						if (testResult.success) {
							workingPostProxies.push(
								path
							);
						}
					} catch (error) {
						resultsHtml += `<div class="test-item">
                        <div class="error">${path}</div>
                        <div>Erreur: ${error.message}</div>
                        <div>❌ Échoué</div>
                    </div>`;
					}
				}

				resultsDiv.innerHTML = resultsHtml;
				updateRecommendations();
			}

			// Tester un chemin de proxy (GET)
			async function testProxyPath(path) {
				try {
					const controller =
						new AbortController();
					const timeoutId = setTimeout(
						() => controller.abort(),
						5000
					);

					const response = await fetch(
						`${path}?endpoint=status.php&_=${Date.now()}`,
						{
							method: "GET",
							signal: controller.signal
						}
					);

					clearTimeout(timeoutId);

					return {
						success: response.ok,
						status: response.status,
						path: path
					};
				} catch (error) {
					console.error(
						`Test failed for ${path}:`,
						error
					);
					return {
						success: false,
						status: "Error",
						path: path,
						error: error.message
					};
				}
			}

			// Tester un chemin de proxy (POST)
			async function testProxyPathPost(path) {
				try {
					const controller =
						new AbortController();
					const timeoutId = setTimeout(
						() => controller.abort(),
						5000
					);

					const response = await fetch(
						`${path}?endpoint=status.php&_=${Date.now()}`,
						{
							method: "POST",
							headers: {
								"Content-Type":
									"application/json"
							},
							body: JSON.stringify({
								test: true
							}),
							signal: controller.signal
						}
					);

					clearTimeout(timeoutId);

					return {
						success: response.ok,
						status: response.status,
						path: path
					};
				} catch (error) {
					console.error(
						`POST test failed for ${path}:`,
						error
					);
					return {
						success: false,
						status: "Error",
						path: path,
						error: error.message
					};
				}
			}

			// Test de connexion directe au backend
			async function testDirectBackend() {
				const resultDiv =
					document.getElementById(
						"direct-result"
					);
				resultDiv.innerHTML = "<p>Test en cours...</p>";

				try {
					const controller =
						new AbortController();
					const timeoutId = setTimeout(
						() => controller.abort(),
						5000
					);

					const response = await fetch(
						"https://app-backend-esgi-app.azurewebsites.net/api/status",
						{
							method: "GET",
							signal: controller.signal
						}
					);

					clearTimeout(timeoutId);

					let responseText = "";
					try {
						responseText =
							await response.text();
					} catch (e) {
						responseText =
							"Impossible de lire la réponse";
					}

					resultDiv.innerHTML = `
                    <div class="${response.ok ? "success" : "error"}">
                        <p>Status: ${response.status}</p>
                        <p>CORS: ${
				response.ok
					? "Aucun problème CORS détecté"
					: "Possible problème CORS"
			}</p>
                        <pre>${responseText}</pre>
                    </div>
                `;

					if (response.ok) {
						recommendations.push(
							"La connexion directe au backend fonctionne. Vous pouvez désactiver le proxy."
						);
					} else {
						recommendations.push(
							"La connexion directe au backend ne fonctionne pas, problème potentiel de CORS. Continuez à utiliser un proxy."
						);
					}

					updateRecommendations();
				} catch (error) {
					resultDiv.innerHTML = `
                    <div class="error">
                        <p>Erreur: ${error.message}</p>
                        <p>La connexion directe a échoué, probablement à cause de CORS.</p>
                    </div>
                `;

					recommendations.push(
						"La connexion directe au backend a échoué. Utilisez un proxy ou la méthode iframe."
					);
					updateRecommendations();
				}
			}

			// Test de la méthode iframe pour contourner CORS et 404
			async function testIframePostMethod() {
				const resultDiv =
					document.getElementById(
						"iframe-result"
					);
				resultDiv.innerHTML = "<p>Test en cours...</p>";

				const endpoint =
					document.getElementById(
						"test-endpoint"
					).value;
				const dataText =
					document.getElementById(
						"test-data"
					).value;

				try {
					const data = JSON.parse(dataText);
					const result = await iframePostFallback(
						endpoint,
						data
					);

					resultDiv.innerHTML = `
                    <div class="success">
                        <p>La méthode iframe a fonctionné!</p>
                        <pre>${JSON.stringify(result, null, 2)}</pre>
                    </div>
                `;

					recommendations.push(
						"La méthode iframe fonctionne et peut être utilisée comme solution de contournement pour les problèmes de CORS et 404."
					);
					updateRecommendations();
				} catch (error) {
					resultDiv.innerHTML = `
                    <div class="error">
                        <p>Erreur: ${error.message}</p>
                        <p>La méthode iframe a échoué.</p>
                    </div>
                `;
				}
			}

			// Fonction pour faire une requête POST en utilisant un iframe (contournement CORS/404)
			function iframePostFallback(endpoint, data) {
				return new Promise((resolve, reject) => {
					const uniqueId = `iframe_fallback_${Date.now()}_${Math.random()
						.toString(36)
						.substr(2, 9)}`;

					// Créer un iframe caché
					const iframe =
						document.createElement(
							"iframe"
						);
					iframe.name = uniqueId;
					iframe.style.display = "none";
					document.body.appendChild(iframe);

					// Créer une fonction de callback pour le résultat
					window[uniqueId] = function (
						responseData
					) {
						resolve(responseData);
						cleanup();
					};

					// Créer un formulaire qui cible l'iframe
					const form =
						document.createElement("form");
					form.action = `https://app-backend-esgi-app.azurewebsites.net/${endpoint}`;
					form.method = "POST";
					form.target = uniqueId;
					form.enctype = "application/json";

					// Ajouter les données au formulaire
					const input =
						document.createElement("input");
					input.type = "hidden";
					input.name = "data";
					input.value = JSON.stringify(data);
					form.appendChild(input);

					// Fonction pour nettoyer les éléments DOM
					function cleanup() {
						document.body.removeChild(
							iframe
						);
						document.body.removeChild(form);
						delete window[uniqueId];
					}

					// Ajouter event listeners
					iframe.onerror = function (error) {
						reject(
							error ||
								new Error(
									"Iframe error"
								)
						);
						cleanup();
					};

					// Soumettre le formulaire
					document.body.appendChild(form);
					form.submit();

					// Définir un timeout
					setTimeout(() => {
						reject(
							new Error(
								"Iframe fallback timed out"
							)
						);
						cleanup();
					}, 15000);
				});
			}

			// Mettre à jour les recommandations
			function updateRecommendations() {
				const recsDiv =
					document.getElementById(
						"recommendations"
					);

				// Générer des recommandations basées sur les tests
				if (workingProxies.length > 0) {
					recommendations.push(
						`Les proxies suivants fonctionnent en GET: ${workingProxies.join(
							", "
						)}`
					);
				} else {
					recommendations.push(
						"Aucun proxy ne fonctionne en GET. Essayez la méthode iframe ou direct-login.php."
					);
				}

				if (workingPostProxies.length > 0) {
					recommendations.push(
						`Les proxies suivants fonctionnent en POST: ${workingPostProxies.join(
							", "
						)}`
					);
				} else if (
					workingPostProxies.length === 0 &&
					workingProxies.length > 0
				) {
					recommendations.push(
						"Les proxies fonctionnent en GET mais pas en POST. Cela indique un problème de configuration sur Azure."
					);
					recommendations.push(
						"Solution recommandée: utilisez la méthode iframe pour contourner ce problème."
					);
				}

				// Afficher la solution de config.js
				recommendations.push(`
                <div class="card">
                    <h3>Solution recommandée pour config.js</h3>
                    <pre>
// Utiliser cette fonction pour les requêtes POST
async function handlePostRequest(endpoint, data, options = {}) {
    // Essayer d'abord avec le proxy
    try {
        const proxyUrl = "simple-proxy.php?endpoint=" + encodeURIComponent(endpoint);
        const response = await fetch(proxyUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data),
            ...options
        });
        
        if (response.ok) return response;
        
        // Si erreur 404, utiliser la méthode iframe
        if (response.status === 404) {
            console.warn("Proxy returned 404, trying iframe fallback");
            return await iframePostFallback(endpoint, data);
        }
        
        return response;
    } catch (error) {
        console.error("Proxy error:", error);
        return await iframePostFallback(endpoint, data);
    }
}</pre>
                </div>
            `);

				// Afficher les recommandations
				recsDiv.innerHTML =
					"<ul>" +
					[...new Set(recommendations)]
						.map((rec) =>
							rec.startsWith("<div")
								? rec
								: `<li>${rec}</li>`
						)
						.join("") +
					"</ul>";
			}

			// Initialisation
			window.onload = function () {
				showEnvironmentInfo();
				testAllProxies();
			};
		</script>
	</body>
</html>
